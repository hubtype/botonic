// TODO: This file contains all the legacy types we had in index.ts. After some refactors, we should be able to get rid of many of them.

export enum CASE_STATUS {
  WAITING = 'status_waiting',
  ATTENDING = 'status_attending',
  IDLE = 'status_idle',
  RESOLVED = 'status_resolved',
}

export type CaseStatusType =
  | CASE_STATUS.ATTENDING
  | CASE_STATUS.IDLE
  | CASE_STATUS.RESOLVED
  | CASE_STATUS.WAITING

export enum CASE_RESOLUTION {
  OK = 'result_ok',
  NOK = 'result_nok',
  NOT_SOLVED = 'result_not_solved',
  BANNED = 'result_banned',
}

export type CaseResolution =
  | CASE_RESOLUTION.BANNED
  | CASE_RESOLUTION.NOK
  | CASE_RESOLUTION.NOT_SOLVED
  | CASE_RESOLUTION.OK

export enum PROVIDER {
  APPLE = 'apple',
  DEV = 'dev',
  FACEBOOK = 'facebook',
  GENERIC = 'generic',
  INSTAGRAM = 'instagram',
  INTERCOM = 'intercom',
  SMOOCH = 'smooch',
  TELEGRAM = 'telegram',
  TWITTER = 'twitter',
  WEBCHAT = 'webchat',
  WECHAT = 'wechat',
  WHATSAPP = 'whatsapp',
}

export type ProviderType =
  | PROVIDER.DEV
  | PROVIDER.FACEBOOK
  | PROVIDER.GENERIC
  | PROVIDER.INSTAGRAM
  | PROVIDER.INTERCOM
  | PROVIDER.SMOOCH
  | PROVIDER.TELEGRAM
  | PROVIDER.TWITTER
  | PROVIDER.WEBCHAT
  | PROVIDER.WECHAT
  | PROVIDER.WHATSAPP

export enum INPUT {
  TEXT = 'text',
  POSTBACK = 'postback',
  AUDIO = 'audio',
  IMAGE = 'image',
  VIDEO = 'video',
  DOCUMENT = 'document',
  LOCATION = 'location',
  CONTACT = 'contact',
  BUTTON_MESSAGE = 'buttonmessage',
  CAROUSEL = 'carousel',
  CUSTOM = 'custom',
  WEBCHAT_SETTINGS = 'webchatsettings',
  WHATSAPP_TEMPLATE = 'whatsapptemplate',
  RAW = 'raw',
  CHAT_EVENT = 'chatevent',
  WHATSAPP_BUTTON_LIST = 'whatsapp-button-list',
  WHATSAPP_CTA_URL_BUTTON = 'whatsapp-cta-url-button',
  WHATSAPP_CATALOG = 'whatsapp-catalog',
  WHATSAPP_PRODUCT = 'whatsapp-product',
  WHATSAPP_PRODUCT_LIST = 'whatsapp-product-list',
  WHATSAPP_PRODUCT_CAROUSEL = 'whatsapp-product-carousel',
  WHATSAPP_MEDIA_CAROUSEL = 'whatsapp-media-carousel',
  WHATSAPP_ORDER = 'whatsapp_order',
  EVENT_AGENT_MESSAGE_CREATED = 'case_event_agent_message_created',
  EVENT_QUEUE_POSITION_CHANGED = 'case_event_queue_position_changed',
  EVENT_CASE_STATUS_CHANGED = 'case_event_status_changed',
  SYSTEM_DEBUG_TRACE = 'system_debug_trace',
}

interface PluginConstructor<T> {
  new (arg: T): Plugin
}

export interface PluginConfig<T> {
  id: string
  options?: T
  resolve: { default: PluginConstructor<T> }
}

export type ResolvedPlugins = Record<string, Plugin>

export type InputType =
  | INPUT.AUDIO
  | INPUT.BUTTON_MESSAGE
  | INPUT.CAROUSEL
  | INPUT.CONTACT
  | INPUT.CUSTOM
  | INPUT.DOCUMENT
  | INPUT.IMAGE
  | INPUT.LOCATION
  | INPUT.POSTBACK
  | INPUT.TEXT
  | INPUT.VIDEO
  | INPUT.CHAT_EVENT
  | INPUT.WEBCHAT_SETTINGS
  | INPUT.WHATSAPP_TEMPLATE
  | INPUT.WHATSAPP_BUTTON_LIST
  | INPUT.WHATSAPP_CTA_URL_BUTTON
  | INPUT.WHATSAPP_CATALOG
  | INPUT.WHATSAPP_PRODUCT
  | INPUT.WHATSAPP_PRODUCT_LIST
  | INPUT.WHATSAPP_PRODUCT_CAROUSEL
  | INPUT.WHATSAPP_MEDIA_CAROUSEL
  | INPUT.WHATSAPP_ORDER
  | INPUT.EVENT_AGENT_MESSAGE_CREATED
  | INPUT.EVENT_QUEUE_POSITION_CHANGED
  | INPUT.EVENT_CASE_STATUS_CHANGED

/** Generated by Translation plugins: GoogleTranslation **/
export interface Translations {
  [languageCode: string]: string
}

export enum NluType {
  Keyword = 'keyword',
  SmartIntent = 'smart-intent',
}

export interface Input {
  text?: string
  src?: string
  data?: string
  path?: string
  payload?: string
  referral?: string
  type: InputType
  context?: {
    campaign?: Campaign
    campaign_v2?: CampaignV2
    salesforce?: {
      access_token: string
    }
  }
  message_id: string
  bot_interaction_id: string
  catalog_id?: string
  product_items?: ProductItem[]
  nluResolution?: {
    type: NluType
    matchedValue: string
    payload?: string
  }
}

export interface CaseEventQueuePositionChangedInput {
  type: INPUT.EVENT_QUEUE_POSITION_CHANGED
  case_id: string
  prev_queue_position: number | null
  prev_queue_position_notified_at: string | null
  current_queue_position: number
  current_queue_position_notified_at: string
  total_queue_waiting_cases_number: number
}

export enum CaseStatus {
  Waiting = 'status_waiting',
  Attending = 'status_attending',
  Idle = 'status_idle',
  Resolved = 'status_resolved',
}

export interface CaseEventStatusChangedInput {
  type: INPUT.EVENT_CASE_STATUS_CHANGED
  case_id: string
  prev_status: CaseStatus | null
  next_status: CaseStatus
}

export interface CaseEventAgentMessageCreatedInput {
  type: INPUT.EVENT_AGENT_MESSAGE_CREATED
  agent_id?: string
  agent_name?: string
  message?: {
    type: string
    data: string
  }
}

interface ProductItem {
  product_retailer_id: string
  quantity: number
  item_price: number
  currency: string
}

export interface Campaign {
  id: string
  name: string
  status: string
  start_date: string
  end_date: string
  bot_path: string
  template_name: string
}

export interface CampaignV2 {
  id: string
  name: string
  agent_context?: string
  end_date?: string
}

export interface ContactInfo {
  name: string
  type: string
  value: string
  description?: string
}

export interface SessionUser<TExtraData = any> {
  id: string
  // login
  username?: string
  // person name
  name?: string
  // whatsapp, telegram,...
  provider: ProviderType
  // The provider's user id
  extra_data?: TExtraData
  contact_info?: ContactInfo[]
  imp_id?: string
  provider_id?: string
  locale: string
  country: string
  system_locale: string
}

export interface HubtypeCaseContactReason {
  id: string
  name: string
  project_id: string
}

export interface SessionBot {
  id: string
  name?: string
}

export interface Session<TExtraData = any> {
  bot: SessionBot
  __retries: number
  _access_token: string
  _hubtype_api: string
  is_first_interaction: boolean
  is_test_integration: boolean
  last_session?: any
  organization_id: string
  organization: string
  user: SessionUser<TExtraData>
  // after handoff
  _botonic_action?: BotonicActionType
  _hubtype_case_resolution?: CaseResolution
  _hubtype_case_id?: string
  _hubtype_case_typification?: string
  _hubtype_case_contact_reasons?: HubtypeCaseContactReason[]
  _shadowing?: boolean
  external?: any
  zendesk_ticket_id?: string
  flow_thread_id?: string
  __campaign?: {
    id: string
    path: string
    active: boolean
  }
}

export type InputMatcher = (input: Input) => boolean
export type ParamsMatcher =
  | { [key: string]: string }
  | ((params: { [key: string]: string }) => boolean)
export type SessionMatcher<TExtraData = any> = (
  session: Session<TExtraData>
) => boolean
export type RequestMatcher<
  TPlugins extends ResolvedPlugins = ResolvedPlugins,
  TExtraData = any,
> = (request: BotContext<TPlugins, TExtraData>) => boolean
export type StringMatcher = RegExp | string | ((data: string) => boolean)

export type RouteMatcher =
  | InputMatcher
  | ParamsMatcher
  | RequestMatcher
  | SessionMatcher
  | StringMatcher

export interface Route<
  TPlugins extends ResolvedPlugins = ResolvedPlugins,
  TExtraData = any,
> {
  action?: any
  childRoutes?: Route[]
  lastRoutePath?: string
  ignoreRetry?: boolean
  path: RoutePath
  redirect?: string
  retry?: number

  // matchers
  input?: InputMatcher
  params?: ParamsMatcher
  payload?: StringMatcher
  request?: RequestMatcher<TPlugins, TExtraData>
  session?: SessionMatcher<TExtraData>
  text?: StringMatcher
  data?: StringMatcher
  type?: StringMatcher
}

export type Routes<R = Route> = R[] | ((request: BotContext) => R[])

export interface BotRequest<TExtraData = any> {
  input: Input
  lastRoutePath: RoutePath
  session: Session<TExtraData>
}

export interface BotContext<
  TPlugins extends ResolvedPlugins = ResolvedPlugins,
  TExtraData = any,
> extends BotRequest<TExtraData> {
  getUserCountry: () => string
  getUserLocale: () => string
  getSystemLocale: () => string
  setUserCountry: (country: string) => void
  setUserLocale: (locale: string) => void
  setSystemLocale: (locale: string) => void
  defaultDelay: number
  defaultTyping: number
  params: Record<string, string>
  plugins: TPlugins
}

/** The response of the bot for the triggered actions, which can be
 * the one matched by the routes, the default action and the retry actions.
 * See Response at @botonic/react's index.d.ts for the React type
 * */
export interface BotResponse extends BotRequest {
  response: any
}

export type PluginPreRequest<
  TPlugins extends ResolvedPlugins = ResolvedPlugins,
  TExtraData = any,
> = BotContext<TPlugins, TExtraData>

export type PluginPostRequest<
  TPlugins extends ResolvedPlugins = ResolvedPlugins,
  TExtraData = any,
> = BotContext<TPlugins, TExtraData> & {
  response: string | null
}

export interface Plugin {
  post?(request: PluginPostRequest): void | Promise<void>
  pre?(request: PluginPreRequest): void | Promise<void>
}

export interface Params {
  [key: string]: any
}

export type Nullable<T> = T | null

export type Action = Nullable<() => any>
export type RoutePath = Nullable<string>

export interface ProcessInputResult {
  action: Action
  emptyAction: Action
  fallbackAction: Action
  lastRoutePath: RoutePath
  params: Params
}

export type MatchedValue = boolean | RegExpExecArray | null

export type RoutingState = {
  currentRoute: Nullable<Route>
  matchedRoute: Nullable<Route>
  params: Params
  isFlowBroken: boolean
}

export interface RouteParams {
  route: Nullable<Route>
  params: Params
}
export interface PathParams {
  path: RoutePath
  params: Params
}

export type MatchingProp =
  | 'text'
  | 'payload'
  | 'type'
  | 'input'
  | 'session'
  | 'request'

export type Matcher = string | RegExp | ((args) => boolean)

export type BotonicActionType =
  | `${BotonicAction.CreateCase}${BotonicActionSeparator}${string}`
  | `${BotonicAction.Redirect}${BotonicActionSeparator}${string}`
  | `${BotonicAction.DiscardCase}${BotonicActionSeparator}${string}`
  | `${BotonicAction.DiscardCase}`
  | `${BotonicAction.DeleteUser}`

type BotonicActionSeparator = ':'

export enum BotonicAction {
  Redirect = 'redirect_action',
  CreateCase = 'create_case',
  DeleteUser = 'delete_user',
  DiscardCase = 'discard_case',
}

// This types are used in the bot-config.ts file to load the bot config when deploy a bot.
export interface BotConfigJSON {
  tools: ToolConfigJSON[]
  payloads: string[]
  webviews: WebviewConfigJSON[]
}

export interface ToolConfigJSON {
  name: string
  description: string
}

export interface WebviewConfigJSON {
  name: string
}
