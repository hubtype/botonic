---
id: webchat
title: Webchat
---

## What is Webchat?

Bots developed with Botonic can be easily deployed to different messaging channels.
Indeed, Botonic's components are specifically treated in order to be executed in a server environment such as Node.Js.
As they are based on React, Botonic components are the perfect fit in order to offer you applications such as Webchat. Webchat is a system that allows you to embed your bots in a web page without requiring any third-party messaging provider.

<details>
<summary>Examples  where embedded Webchats can be triggered by clicking the chat bubble.</summary>

![](https://botonic-doc-static.netlify.com/images/webchat_usage.png)

</details>

## Browser Versions Supported by Default

Botonic supports the following browsers:

| Browser               | Version                                                               |
| --------------------- | --------------------------------------------------------------------- |
| Chrome                | 61 and later                                                          |
| Mozilla Firefox       | 56 and later                                                          |
| Opera                 | 41 and later                                                          |
| Safari                | 11 and later                                                          |
| Safari (iOS versions) | 11.3 and later                                                        |
| Edge                  | 79 and later                                                          |
| Internet Explorer     | **[11 (with polyfills)](#how-to-make-your-bot-compatible-with-ie11)** |

## Storage

By default, Botonic stores its state in the [**localStorage**](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) browser where the data doesn't expire.

However, for security and privacy reasons, you may have to avoid storing bot data.

That's why Botonic also allows you to store on the [**sessionStorage**](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) where everything is cleared once the webchat window is closed or reloaded.

If you don't want to store anything in the browser, the **`null`** variable is recommended.

To specify the required storage type, add:

```javascript
export const webchat = {
  storage: {localStorage|sessionStorage|null}
}
```

## Webchat SDK API

Once your Webchat is integrated, you are provided with a code snippet to be embedded in your page.
This snippet will load your bot's code and will allow managing it through the following JS functions (you can test it in your current browser's developers console).

These methods are:

- `Botonic.open()`: Opens the webchat window if it's closed.
- `Botonic.close()`: Closes the webchat window if it's open.
- `Botonic.toggle()`: Opens or closes the webchat window depending on the current state.
- `Botonic.setTyping(boolean)`: Sets the visibility of the typing indicator.
- `Botonic.addUserText(string)`: Sends a text to the bot as if the user sent it.
- `Botonic.addUserPayload(string)`: Sends a payload to the bot as if the user sent it.
- `Botonic.addBotText(string)`: Adds a new message in the webchat window as if the bot sent it.
- `Botonic.updateUser(Object)`: Updates the attributes of the user. `({id: '1234', name: 'Pepito'})`
- `Botonic.getVisibility()`: Sets the visibility of the webchat window.
- `Botonic.openCoverComponent()`: Opens an authentication window.
- `Botonic.closeCoverComponent()`: Closes the authentication window.
- `Botonic.toggleCoverComponent()`: Opens or closes the authentication window depending on the current state.

### Webchat Listeners

In the same way, sometimes you would want to react to some of the events that take place when some actions occur in the Webchat. To react to the actions that occur in the Webchat, you can define the following event listeners:

**`Snippet to be embedded`**

```html
<html>
  <head>
    <script
      type="text/javascript"
      src="{BOT_DOMAIN}/webchat.botonic.js"
    ></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>
  <body>
    <div id="root"></div>
    <script type="text/javascript">
      document.addEventListener('DOMContentLoaded', function (event) {
        Botonic.render(document.getElementById('root'), {
          appId: 'YOUR_APP_ID',
          onInit: app => console.log('Webchat initialized!'),
          onOpen: app => console.log('Webchat opened!'),
          onClose: app => console.log('Webchat closed!'),
          onMessage: (app, msg) => console.log('Current message', msg),
        })
      })
    </script>
  </body>
</html>
```

It can be used as well in **`src/webchat/index.js`**.

```javascript
export const webchat = {
  onInit: app => {
    // You can combine webchat listeners with the Webchat SDK's Api in order
    // to obtain extra functionalities. This will automatically open the webchat once the site is loaded.
    app.open()
  },
  onOpen: app => {
    app.addUserPayload('INITIAL_PAYLOAD')
  },
  onClose: app => {
    console.log('Webchat closed!')
  },
  onMessage: app => {
    // Your stuff here
  },
}
```

### Images

Static assets or a plain URL can be set for the following webchat properties:

- `message.bot.image`
- `header.image`
- `intro.image`
- `triggerButton.image`

**Example:**

```
export const webchat = {
  theme: {
    triggerButton: {
      image: "https://domain.com/my-logo.png",
    },
    message: {
      bot: {
        image: "https://domain.com/my-logo.png",
      },
    },
    header: {
      image: "https://domain.com/my-logo.png",
    },
    intro: {
      image: "https://domain.com/my-logo.png",
    },
  },
};
```

## Customizing Webchat

Another great advantage of Webchat is that you can customize its components. This can be done by changing the values of a set of attributes or you can let your imagination run free to achieve great results by creating your own components from scratch!

### Markdown Style

By default, webchat supports markdown syntax.

1. In one of your actions, enter the following example.

   ```javascript
   export default class extends React.Component {
     render() {
       const renderTable = () => {
         return (
           '## Tables\n' +
           '| Option | Description |\n' +
           '| ------ | ----------- |\n' +
           '| data   | path to data files to supply the data that will be passed into templates. |\n' +
           '| engine | engine to be used for processing templates. Handlebars is the default. |\n' +
           '| ext    | extension to be used for test files. |\n' +
           '<br/><br/>\n'
         )
       }
       return <Text>{renderTable()}</Text>
     }
   }

   export default class extends React.Component {
     render() {
       // markdown={true} is set by default
       return (
         <Text>
           # Heading 1{'\n'}
           ## Heading 2{'\n'}
           ### Heading3
         </Text>
       )
     }
   }
   ```

   <details>
   <summary>Output example</summary>

   ![](https://botonic-doc-static.netlify.com/images/markdown/mdwebchat1.png)

   </details>

2. Customize the style in the `index.js` file.

   **webchat/index.js**

   ```javascript
   theme: {
       markdownStyle: `
       * {
         margin: 0px;
       }
       a {
         text-decoration:none;
         font-weight:bold;
       }
       h1 {
         color: green;
       }
       h2 {
         color: purple;
       }
       a:visited {
         color: blue;
       }`,
     },
   ```

   <details>
   <summary>Output example</summary>

   ![](https://botonic-doc-static.netlify.com/images/markdown/mdwebchat2.png)

   </details>

#### Multiline Support

To use multiple line breaks, you must add
`</br>` tags in your js file, or use a function which returns `</br>` tags in the string.
You get an additional line break between "## Links Examples" and "---" separator.

```javascript
return (
  <Text>
    ## Links Examples
    <br />
    <br />
    {'\n'}---
    {'\n'}__Advertisement :)__
    {'\n'}- __[pica](https://nodeca.github.io/pica/demo/)__ - high quality and fast
    image resize in browser.
    {'\n'} - __[babelfish](https://github.com/nodeca/babelfish/)__ - developer
    friendly i18n with plurals support and easy syntax. You will like those
    projects!
    {'\n'}---
  </Text>
)
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/docs/concepts_wmultiline.png)

</details>

### Conversation Window Format

You can customize the border and pointer of a conversation window (also called blobTick).

- The border of the blobTick is displayed if the message border color is defined by using `borderColor`.
- `blobTickStyle` can be used to set the position of the pointer.

```javascript
message: {
 bot: {
  style: {
   border: '1px solid black',
   borderColor: 'black',
  },
  blobTickStyle: {
   alignItems: 'flex-end',
  },
 },
},
```

- You can define a top or bottom padding element to set an exact position.

```javascript
blobTickStyle: {
 alignItems: 'flex-end',
 paddingBottom: '30px',
},
```

**Note:** You cannot use `blobTick` for `blockInputs`.

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/docs/concepts_wblobtick.png)

</details>

### Cover Component

The Cover component enables the user to authenticate when starting a conversation. In that way, you can retrieve relevant information at the very beginning of the interaction, such as the user's name or e-mail address.

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/covercomponent.png)

</details>

**Note:** In this example, we are using `@material-ui/core` so make sure to install it by running `npm i @material-ui/core`.

1. Create a `cover-component.js` in `src/webchat`.

2. Add the component details as in the example below.

```javascript
import React from 'react'
import styled from 'styled-components'
import TextField from '@material-ui/core/TextField'
import { WebchatContext } from '@botonic/react'

const Container = styled.div`
  position: absolute;
  left: 17%;
  top: 20%;
  background: white;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
`
const Button = styled.button`
  width: 80px;
  height: 40px;
  background: #2f2f2f;
  border-radius: 8px;
  margin-top: 20px;
  text-align: center;
  color: white;
`
const Form = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: center;
`
function MyTextField(props) {
  return (
    <TextField
      label={props.label}
      variant='filled'
      onChange={props.onChange}
      error={props.value === '' && props.error === true}
      value={props.value}
      disabled={props.disabled}
      style={{ width: '80%', margin: '5px' }}
    />
  )
}
export default class CustomCover extends React.Component {
  static contextType = WebchatContext
  constructor(props) {
    super(props)
    this.state = {
      error: false,
      name: '',
      email: '',
    }
  }
  verifiedForm() {
    if (this.state.name === '' || this.state.email === '') return false
    return true
  }
  close() {
    if (this.verifiedForm()) {
      this.context.updateUser({
        name: this.state.name,
        email: this.state.email,
      })
      this.context.sendText('START', 'PAYLOAD')
      this.props.closeComponent()
    } else {
      this.setState({ error: true })
    }
  }
  handleName = event => {
    this.setState({ name: event.target.value })
  }
  handleEmail = event => {
    this.setState({ email: event.target.value })
  }
  render() {
    return (
      <Container>
        <h2>Contact Info</h2>
        <Form>
          <MyTextField
            label='Name'
            onChange={this.handleName}
            value={this.state.name}
            error={this.state.error}
          />
          <MyTextField
            label='Email'
            onChange={this.handleEmail}
            value={this.state.email}
            error={this.state.error}
          />
          <Button onClick={() => this.close()}>START</Button>
        </Form>
      </Container>
    )
  }
}
```

3. In the `index.js` file located in `src/webchat`, import the component as in the example below.

```javascript webchat = {
import CustomCover from './cover-component'
export const webchat = {
  coverComponent: CustomCover,
}
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/covercomponent2.png)

</details>

When the user authenticates:

- The information is stored in the user information (`session.user` and `user`).

- The component is closing.

- The **START** user message is displayed and the action with a **PAYLOAD** is called.

**Note**: by default, the input zone is disabled before the user authentication.

### Enabling/Disabling Webchat

You can allow the Hubtype Desk user to enable or disable its webchat whenever he wants. An API call to the backend will be done to determine if the webchat should be shown or not.

**Note:** This functionality is available from Botonic v0.13.0 and above.

1. To enable the webchat view on a permanent basis, you must pass the `visibility` parameter to `true` in `webchat/index.js`.

```javascript
export const webchat = { visibility: true }
```

2. To be able to enable or disable the webchat, you can define the webchat view with a function that returns `true` (visible) or `false` (not visible).

```javascript
Botonic.render(document.getElementById('root'), {
  appId: 'MY APP ID',
  visibility: function () {
    const result =
    return Boolean(result)
  },
})
```

Therefore, in Hubtype Desk:

- The checkbox is set to `visible`.
- The requester url is in the whitelisted domains.
- The queue linked to the webchat is open.

**Note:** The webchat is still visible if no settings are defined (webchat without set values) and if the whitelisted urls list is empty, e.g. `[]`

### Dynamic Updates

The `WebchatSettings` component offers a dynamic bot interaction, where webchat properties can be updated on the run depending on the conversation.

Let's say you want to prepare the following behavior when starting the conversation:

- The webchat window color is changed to black.
- The text input is hidden.
- Attachements are enabled.
- There is a `blockInputs`.

1. Add the following content in your **action** file.

```javascript
import React, { useContext } from 'react'
import { Text, Reply, WebchatSettings } from '@botonic/react'
import { RequestContext } from '@botonic/react'

export default class extends React.Component {
  static contextType = RequestContext
  render() {
    return (
      <>
        <Text>
          Please, type "start" to start the tutorial.
          <Reply payload='reply1'>Reply 1</Reply>
          <Reply payload='reply2'>Reply 2</Reply>
        </Text>
        <WebchatSettings
          theme={{
            brand: { color: 'black' },
          }}
          blockInputs={[
            { match: [/ugly/i, /bastard/i], message: "don't say that to me" },
          ]}
          enableAttachments={true}
          enableUserInput={false}
        />
      </>
    )
  }
}
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/dynamic_updates1.png)

</details>

Now you want to get the following behavior during the conversation:

- A response is given to the previous action.
- The text input is enabled again.
- The webchat window color turns to orange.
- The `emojiPicker` is enabled.
- A `persistentMenu` is dynamically added.

2. Add the following content in your **action** file.

```javascript
import React from 'react'
import { Text, WebchatSettings } from '@botonic/react'

export default class extends React.Component {
  render() {
    return (
      <>
        <Text>Ok dude ðŸ˜‰</Text>
        <WebchatSettings
          theme={{
            brand: { color: 'orange' },
          }}
          enableEmojiPicker={true}
          persistentMenu={[
            { label: 'option1', payload: 'opt1' },
            { label: 'option2', payload: 'opt2' },
          ]}
          enableUserInput={true}
        />
      </>
    )
  }
}
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/dynamic_updates2.png)

![](https://botonic-doc-static.netlify.com/images/webchat/dynamic_updates3.png)

</details>

3. Finally, a simple action can be added just to change the color (as `WebchatSettings` only returns visual changes):

```javascript
export default class extends React.Component {
  render() {
    return <WebchatSettings theme={{ brand: { color: 'green' } }} />
  }
}
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/dynamic_updates4.png)

</details>

### Custom Webchat Template

[**View on Github**](https://github.com/hubtype/botonic/tree/master/packages/botonic-cli/templates/custom-webchat)

This template allows you to create custom elements for Webchat. All custom components are stored in `src/webchat`.

**src/webchat/index.js**

```javascript
export const webchat = {

  // Webchat styling
  theme: {},

  // Webchat features
  persistentMenu: [],
  blockInputs: [],
  enableEmojiPicker: {true|false},
  enableUserInput: {true|false},
  enableAttachments: {true|false},
  enableAnimations: {true|false},
  visibility: {true|false|'dynamic'|() => Boolean()},
  coverComponent: React.Component,

  // Webchat listeners
  onInit: app => {},
  onOpen: app => {},
  onClose: app => {},
  onMessage: app => {}
}
```

This Webchat template allows definitions that enable you to configure the following examples:

### Theme

- **theme**: Define your **[webchat styles](#webchat-styles)**.

### Features

- **persistentMenu**: A persistent menu can be accessed from a small button in the input text box. It allows the user to access popular functionalities anywhere in the conversation.
- **blockInputs**: Enables you to define which user input is forbidden. It is useful to prevent the user from entering a credit card number.
- **enableEmojiPicker**: Enables the emoji picker. It can also be defined in `theme.userInput.enableEmojiPicker`. The `false` value is set by default.
- **enableAttachments**: Authorizes user media attachments or not (`true|false`). It can also be defined in `theme.userInput.attachments.enable`. The `false` value is set by default.
- **enableUserInput**: Enables the user typing zone (`true|false`). It can also be defined in `theme.userInput.enable`. `true` by default.
- **enableAnimations**: Enables webchat animations (`true|false`). `true` by default. It can also be defined in `theme.animations.enable`.
- **visibility**: To make webchat visible or not. If you want to use the settings defined in Hubtype Desk, you must set this value to `'dynamic'`. You can pass a boolean `true` to make it visible or `false` to make it invisible, or you can define a function returning a boolean resolving the visibility.
- **coverComponent**: A `React.Component` shown the first time a user interacts with the Webchat.

### Listeners

Listeners are useful to react to some events when using the webchat.

- **onInit**: This event is triggered once the webchat is loaded in the webpage.
- **onOpen**: This event is triggered once the webchat has been opened.
- **onClose**: This event is triggered once the webchat has been closed.
- **onMessage**: This event is triggered once a message is sent by the enduser or the bot.

### Webchat Styles

Here is a list of available styles. You need to modify them inside **src/webchat/index.js**'s `theme` object:

<details>
<summary>General Style</summary>

Botonic allows you to modify the following styles:

- **mobileBreakpoint**: Width (in pixels) for mobile responsive design. Set to `460` pixels by default.

* **style**: The main characteristics of webchat such as size, background color, etc.

- **webviewStyle**: The main characteristics of your webviews such as size, background color, etc. It can also be defined in `webview.style`.

* **webviewHeaderStyle**: Styles for the webview header. It can also be defined in `webview.header.style`.

- **triggerButtonImage**: Launcher icon to toggle the webchat. It can also be defined in `triggerButton.image`.

* **triggerButtonStyle**: Launcher icon styles. It can also be defined in `triggerButton.style`.

- **brandColor**: The main color palette of the webchat widget. It can also be defined in `brand.color`.

* **brandImage**: It sets an image for both `headerImage` and `botMessageImage`. It can also be defined in `brand.image`.

- **headerImage**: The image displayed in the header. Overwrites the one set in brandImage. You can set it to `null` to disable it. It can also be defined in `header.image`.

* **headerTitle**: Displays webchat title. It can also be defined in `header.title`.

- **headerSubtitle**: Displays webchat subtitle. It can also be defined in `header.subtitle`.

* **headerStyle**: Header styles. It can also be defined in `header.style`.

- **buttonStyle**: Button styles. It can also be defined in `button.style`.

* **buttonHoverBackground**: Background color when hovering over a button. It can also be defined in `button.hoverBackground`.

- **buttonHoverTextColor**: Text color when hovering over a button. It can also be defined in `button.hoverTextColor`.

* **replyStyle**: Styles for replies. It can also be defined in `reply.style`.

- **alignReplies**: Aligns replies at `left`, `center` or `right`. It can also be defined in `replies.align`.

* **wrapReplies**: Whether replies be displayed on a single row `nowrap` (horizontal scrolling is displayed when required) or it is wrapped in different lines `wrap`. It can also be defined in `replies.wrap`.

- **botMessageImage**: The image displayed next to the bot's chat bubble. Overwrites the one set in brandImage. You can set it to `null` to disable it. It can also be defined in `message.bot.image`.

* **botMessageStyle**: Styles of bot message. It can also be defined in `message.bot.style`.

- **userMessageStyle**: Styles of user message. It can also be defined in `message.user.style`.

* **introImage**: An introductory image shown the first time the conversation is initialized. It can also be defined in `intro.image`.

- **introStyle**: Styles of the introductory image. It can also be defined in `intro.style`.

* **textPlaceholder**: Text placeholder in the input text. It can also be defined in `userInput.box.placeholder`.

- **enableUserInput**: Set it to `false` if you want to disable text input. It can also be defined in `userInput.enable`. `true` by default.

* **userInputStyle**: Styles for the bottom area of the user input. It can also be defined in `userInput.style`.

- **userInputBoxStyle**: Styles for the text input box. It can also be defined in `userInput.box.style`.

* **emojiPicker**: Set it to `true` to enable the emoji picker. It can also be defined in `userInput.emojiPicker`. `false` by default.

- **blockInputs**: The inputs not allowed by the bot. It can also be defined in `userInput.blockInputs`.

* **persistentMenu**: An array containing the options of your persistent menu. It can also be defined in `userInput.persistentMenu`.

- **enableAttachments**: Whether to allow user media attachments or not (`true|false`). It can also be defined in `userInput.attachments.enable`. `false` by default.

* **scrollbar**: Refer to the example below **`src/webchat/index.js`** for a complete description of scrollbar's customizable attributes.

**Note**: By specifying the `fontFamily` attribute in `style` property, you can overwrite your webchat entire typography.

</details>

<details>
<summary>Custom Components</summary>
You can also create your own components from scratch.

- **customIntro:** React component that is injected where introImage is displayed. It can also be defined in`intro.custom`.
- **customTrigger:** React component that is injected in the Launcher icon. It can also be defined in`triggerButton.custom`.
- **customHeader:** React Component that is injected in the Header of the widget. It can also be defined in`header.custom`.
- **customReply:** React Component that is injected in the Reply components of the widget. It can also be defined in`reply.custom`.
- **customButton:** React Component that is injected in the Button components of the widget. It can also be defined in`button.custom`.
- **customSendButton:** A fully customizable send button. It can also be defined in`userInput.sendButton.custom`.
- **customMenuButton:** A fully customizable button for trigger the persistent menu. It can also be defined in`userInput.menuButton.custom`.

**Note**: Custom components redefine completely the components that are replacing, so the styles in conflicts with these components are overridden.

</details>

<details>
<summary>Custom Message Styles</summary>
Additionally, you can create the kind of messages you want:

- **customMessageTypes:** Array of React components representing your messages. It can also be defined in `message.customTypes`.

</details>

### Custom Message Styles

**src/webchat/calendar-message.js**

```javascript
import React from 'react'
import { WebchatContext, customMessage } from '@botonic/react'
import Calendar from 'react-calendar'

class CalendarMessage extends React.Component {
  static contextType = WebchatContext

  render() {
    return (
      <>
        <Calendar
          onChange={date =>
            this.context.sendText(`Booked for ${date.toLocaleDateString()}`)
          }
        />
        <p>{this.props.children}</p>
      </>
    )
  }
}

export default customMessage({
  name: 'calendar',
  component: CalendarMessage,
})
```

Take a look at the infographics below to know exactly what are the parts that are customized when changing the `theme attributes`.

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/customization1.png)

![](https://botonic-doc-static.netlify.com/images/customization2.png)

</details>

### Custom Component

In this example, we are putting CSS styles into a custom 'quickreply'.
It's very important to put `{props.children}` inside the container, in this case the `<div>` tag:

**src/webchat/custom-reply.js**

```javascript
import React from 'react'

export const CustomReply = props => (
  <div
    style={{
      color: '#0000ff',
      border: '2px solid #0000ff',
      backgroundColor: 'white',
      borderRadius: 30,
      padding: 8,
      cursor: 'pointer',
    }}
  >
    {props.children}
  </div>
)
```

This is an example of a custom Reply for our webchat. We can put all the fancy CSS styles we want.
This is a static object, so it's not applied in any [component](/docs/components/components), so we don't have to put `{props.children}` inside any container.

**src/webchat/custom-intro.js**

```javascript
import React from 'react'
import { staticAsset } from '@botonic/react'
import Img from '../assets/intro-image.jpg'

export const CustomIntro = () => (
  <img height={'50%'} width={'100%'} src={staticAsset(Img)} />
)
```

**Note:** When you define custom components that use static assets as shown in the example above, you must use the the method `staticAsset` from `@botonic/react` in order to get it working properly in production environment.

**src/webchat/index.js**

```javascript
import launcherIcon from '../assets/launcher-logo.png'
import IntroImage from '../assets/intro-image.jpg'
import C3POLogo from '../assets/c3po-logo.png'
import R2D2Logo from '../assets/r2d2-logo.png'
import CalendarMessage from './calendar-message'
import { CustomTrigger } from './custom-trigger'
import { CustomHeader } from './custom-header'
import { CustomIntro } from './custom-intro'
import { CustomReply } from './custom-reply'
import { CustomButton } from './custom-button'

export const webchat = {
  theme: {
    mobileBreakpoint: 460,
    style: {
      position: 'fixed',
      right: 20,
      bottom: 20,
      width: 400,
      height: 500,
      margin: 'auto',
      backgroundColor: 'white',
      borderRadius: 25,
      boxShadow: '0 0 50px rgba(0,0,255,.30)',
      overflow: 'hidden',
      backgroundImage:
        'linear-gradient(to top, #ffffff,#ffffff 11%,#9a9ae3 40%,#0000ff 85%,#0000ff 85%)',
      fontFamily: '"Comic Sans MS", cursive, sans-serif',
    },
    webview: {
      style: {
        top: 0,
        right: 0,
        height: 500,
        width: '100%',
      },
      header: {
        style: {
          background: '#6677FF',
        },
      },
    },

    brand: {
      // color: 'blue',
      image: R2D2Logo,
    },
    triggerButton: {
      image: launcherIcon,
      style: {
        width: '200px',
      },
      // custom: CustomTrigger,
    },
    intro: {
      // image: IntroImage,
      // style: {
      //   padding: 20
      // }
      custom: CustomIntro,
    },
    header: {
      title: 'My customized webchat',
      subtitle: 'R2D2',
      image: R2D2Logo,
      style: {
        height: 70,
      },
      // custom: CustomHeader
    },
    /*
     * brandImage will set both headerImage and botMessageImage with its current logo
     * you can overwrite these values by redefining them individually
     */
    message: {
      bot: {
        image: C3POLogo, // set it to 'null' to hide this image
        style: {
          border: 'none',
          color: 'black',
          borderRadius: '20px',
          background: '#e1fcfb',
        },
      },
      user: {
        style: {
          // border:'none',
          color: 'white',
          background: '#2b81b6',
          borderRadius: '10px',
        },
      },
      customTypes: [CalendarMessage],
    },

    button: {
      style: {
        color: 'black',
        background: 'white',
        borderRadius: 20,
      },
      hoverBackground: '#b3fcfa',
      hoverTextColor: 'black',

      // custom: CustomButton,
    },
    replies: {
      align: 'center',
      wrap: 'nowrap',
    },
    reply: {
      style: {
        color: 'black',
        background: '#e1fcfb',
        borderColor: 'black',
      },
      // custom: CustomReply,
    },
    userInput: {
      style: {
        background: 'black',
      },
      box: {
        style: {
          border: '2px solid #2b81b6',
          color: '#2b81b6',
          background: '#F0F0F0',
          width: '90%',
          borderRadius: 20,
          paddingLeft: 20,
          marginRight: 10,
        },
        placeholder: 'Type something...',
      },

      // enable: false,
      attachments: {
        enable: true,
      },

      emojiPicker: {
        enable: true
      },

      // These are the set of inputs which are not allowed.
      blockInputs: [
        {
          match: [/ugly/i, /bastard/i],
          message: 'We cannot tolerate these kind of words.',
        },
      ],
      persistentMenu: [
        { label: 'Help', payload: 'help' },
        {
          label: 'See docs',
          url: 'https://docs.botonic.io',
        },
        { closeLabel: 'Close' },
      ],
    },
    scrollbar: {
      // enable: false,
      autoHide: true,
      thumb: {
        opacity: 1,
        // color: 'yellow',
        bgcolor:
          'linear-gradient(-131deg,rgba(231, 176, 43) 0%,rgb(193, 62, 81) 100%);',
        border: '20px',
      },
      // track: {
      //   color: 'black',
      //   bgcolor:
      //     'linear-gradient(-131deg,rgba(50, 40, 43) 0%,rgb(125, 62, 81) 100%);',
      //   border: '20px',
      // },
    },
  },
```

All these changes can be tested using the `botonic serve` command (`npm run start` on Windows).

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat_example.png)

</details>

### Persistent Menu

By adding the following lines of code in the webchat's object, you can enable a persistent menu. You can redefine the label for closing the persistent menu with `closeLabel`. Default text is `'Cancel'`.

```javascript
persistentMenu: [
  { label: "Home", payload: "hi" },
  { label: "Human Agent", payload: "help" },
  { closeLabel: "Close Menu" },
],
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat_persistent_menu.png)

</details>

The persistent menu accepts the same properties as Botonic Buttons, e.g.: `payload` and `url`.

### Trigger Button Customization

You can first customize the persistent menu button with the `theme.customMenuButton` or `theme.userInput.menuButton.custom` properties.

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/persmenu-button.png)

</details>

To do so:

1. Add an image for the button in the **Assets** folder.
2. Create a `custom-menu-button.js` file.
3. Customize the button as shown in the example below.

**src/webchat/custom-menu-button.js**

```javascript
import React from 'react'
import styled from 'styled-components'

export const IconContainer = styled.div`
  cursor: pointer;
  width: 56px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
`
export const Icon = styled.img`
  width: 18px;
`
export const CustomMenuButton = () => (
  <IconContainer>
    <Icon src={'https://image.flaticon.com/icons/svg/2948/2948037.svg'} />
  </IconContainer>
)
```

### Menu Customization

#### 1. Creating a Custom Menu Button

In order to have your entire persistent menu customized, first you will need to create a unitary button for each of the options. To do so, you can create a component like this one:

**src/webchat/custom-persistent-menu-button.js**

```javascript
import React, { useContext } from 'react'
import styled from 'styled-components'
import { WebchatContext } from '@botonic/react'
import { Icon, IconContainer } from './custom-menu-button'

const StyledButton = styled.div`
  cursor: pointer;
  height: 50px;
  width: 100%;
  background: white;
  display: flex;
  justify-content: left;
  align-items: center;
`

const Text = styled.p`
  @import url('https://fonts.googleapis.com/css?family=Lato:300,400,700');
  font-family: Lato;
  font-size: 15px;
  font-weight: 400;
  color: black;
  text-align: left;
`

export const CustomPersistentMenuButton = props => {
  const { sendInput } = useContext(WebchatContext)
  return (
    <StyledButton
      onClick={() => {
        props.payload
          ? sendInput({
              type: 'text',
              data: String(props.label),
              payload: props.payload,
            })
          : props.onClick()
      }}
    >
      <IconContainer>
        <Icon src={props.img} />
      </IconContainer>
      <Text
        style={{
          color: 'black',
        }}
      >
        {props.label}
      </Text>
    </StyledButton>
  )
}
```

#### 2. Use Custom Menu Buttons in CustomPersistentMenu

Then to customize the persistent menu, you must use the `theme.userInput.menu.custom` or `theme.customPersistentMenu` property.
To do so:

1. Create a `custom-persistent-menu.js` file.
2. Customize the menu as shown in the example below.

```javascript
import React from 'react'
import styled from 'styled-components'
import { CustomPersistentMenuButton } from './custom-persistent-menu-button'

const ButtonsContainer = styled.div`
  width: 100%;
  bottom: 0;
  position: absolute;
  z-index: 2;
  text-align: center;
`

export const CustomPersistentMenu = ({ onClick, options }) => {
  return (
    <ButtonsContainer>
      <CustomPersistentMenuButton
        label={options[0].label}
        payload={options[0].payload}
        img={'https://image.flaticon.com/icons/svg/2948/2948025.svg'}
      />
      <CustomPersistentMenuButton
        label={options[1].label}
        payload={options[1].payload}
        img={'https://image.flaticon.com/icons/svg/2948/2948059.svg'}
      />
      <CustomPersistentMenuButton
        label={options[2].closeLabel}
        onClick={onClick}
        img={'https://image.flaticon.com/icons/svg/271/271203.svg'}
      />
    </ButtonsContainer>
  )
}
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/webchat_custommenu.png)

</details>

#### Dark background

This option is used to darken the webchat in the background and focus on the persistent menu only. It can be defined under the properties `theme.darkBackgroundMenu` or `theme.menu.darkBackground`.

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat/darkbg.png)

</details>

This is how it should look like in your final webchat file.

**src/webchat/index.js**

```javascript
import { CustomPersistentMenu } from './custom-persistent-menu'
import { CustomMenuButton } from './custom-menu-button'

export const webchat = {
  theme: {
    userInput: {
      persistentMenu: [
        { label: 'Home', payload: 'hi' },
        { label: 'Human Agent', payload: 'help' },
        { closeLabel: 'Close Menu' },
      ],
      menu: {
        darkBackground: true,
        custom: CustomPersistentMenu,
      },
      menuButton: {
        custom: CustomMenuButton,
      },
    },
  },
}
```

### Timestamp

Timestamps are used to add and customize the time and date (color, position, locale) below the chat message. They are disabled by default.

To enable timestamps:

1. Set `theme.message.timestamps.enable` to `true`. The format displayed by default for all locales and formatted with [toLocaleString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString) will look like 29 Jun, 12:40:07.

Example in webchat `index.js` file.

```javascript
theme: {
    message: {
      timestamps: {
        enable: true,
      },
    },
  },
```

2. Define `style` and `format` properties:

```javascript
theme: {
    message: {
      timestamps: {
        format: () => {
          return new Date().toLocaleString();
        },
        style: {
          color: "blue",
        },
      },
    },
  },
```

### Block Inputs

For security reasons or to avoid harmful or threatening messages, you can block these inputs:

```javascript
blockInputs: [
  {
    match: [/ugly/, /bastard/],
    message: 'We cannot tolerate these kind of words.',
  },
]
```

<details>
<summary>Example</summary>

![](https://botonic-doc-static.netlify.com/images/webchat_block_inputs.png)

</details>

Once the specified inputs are matched:

- The user input is not displayed in the message history.
- The configured message is displayed.
- The bot does not receive the blocked message.

## How to make your bot compatible with IE11

To make a bot compatible with IE11, its javascript code must be compliant with ES5. To do so, babel is used to transpile all the code.

### Prepare the bot

To make the bot work in IE11:

1. Add the following meta in the bot's integration code:

```javascript
&lt;meta http-equiv="X-UA-Compatible" content="IE=11" /&gt;
```

2. If style rendering issues occur, disable webchat animations:

```javascript
theme: {
  animations: {
    enable: false,
  },
}
```

### Add polyfills

Some functionalities supported by most browsers are not implemented in IE11. To use them, polyfills are needed.

Here is a list of polyfills used in some of the bots:

- Basic polyfills: **[core-js](https://www.npmjs.com/package/core-js)**
- Style issues: **[@webcomponents/webcomponentsjs](https://www.npmjs.com/package/@webcomponents/webcomponentsjs)**
- scrollTo feature: **[element-scroll-polyfill](https://www.npmjs.com/package/element-scroll-polyfill)**
- normalize: **[unorm](https://www.npmjs.com/package/unorm)**

To add polyfills:

1. Open the `webpack.config.js` file.

2. Add all the polyfills that are currently used in the entry property within the `botonicWebchatConfig`.

```javascript
entry: [
  'core-js/stable/',
  'regenerator-runtime/runtime',
  '@webcomponents/webcomponentsjs',
  'element-scroll-polyfill',
  'unorm',
  path.resolve('src', 'webchat-entry.ts'),
],
```

**Note:** `core-js/stable`, `regenerator-runtime/runtime`, `@webcomponents/webcomponentsjs` and `element-scroll-polyfill` are mandatory.

### Configure the Babel loader

When configuring the Babel loader to transpile code to ES5 compliance, some options must be added/configured.

1. Set `sourceType` to 'unambiguous' (cf. issue: https://github.com/babel/babel/issues/8900 )

2. Add plugins to transform some new functionalities from ES6 to ES5. For example: [the arrow functions](https://www.npmjs.com/package/@babel/plugin-transform-arrow-functions)

```javascript
options: {
  sourceType: 'unambiguous',
  cacheDirectory: true,
  presets: [
    '@babel/react',
    [
      '@babel/env',
      {
        targets: {
          ie: '11',
        },
        useBuiltIns: 'entry',
        corejs: 3,
        modules: false, // Needed for tree shaking to work.
      },
    ],
    '@babel/typescript',
  ],
  plugins: [
    require('@babel/plugin-proposal-object-rest-spread'),
    require('@babel/plugin-proposal-class-properties'),
    require('babel-plugin-add-module-exports'),
    require('@babel/plugin-transform-runtime'),
    require('@babel/plugin-transform-object-assign'),
    require('@babel/plugin-transform-arrow-functions'),
    require('@babel/plugin-transform-classes'),
  ],
}
```

### Load the bot and correct the dependencies

You can now load the bot in IE11. If an error still occurs despite the correct configuration in `webpack.config.js`, you can solve it by finding the error and the dependency that produces the error.

To do so:

1. Open the developer tool (F12).
2. Click on the error messages line to display the exact part of the code where the error occurs.
3. Search for parts of the code that are unique/exclusive of a package. E.g. function names, class names, text messages, etc.
4. Look for these parts in the `node_modules` folder to see which dependency contains that piece of code.
5. Once the dependency that produces the error is found, add it to babel to transpile its code to ES5.
6. Add the name of the dependency in the exclude option (regexp) to include it.

Example with babel transpiling the dependency "axios":

Before: `exclude: /node_modules[\/\\](?!(styled-components|@emotion|@rehooks|@botonic\/(core|react|plugin-google-analytics))[\/\\])/,`

After: `exclude: /node_modules[\/\\](?!(axios|styled-components|@emotion|@rehooks|@botonic\/(core|react|plugin-google-analytics))[\/\\])/,`

### Known IE11 issues

- **SCRIPT445: Object doesn't support this action:** This error may appear due to the use of the `babel-plugin-add-module-exports` plugin. If the bot is using this plugin try to remove it and see if the error disappears"
- **Parameter properties (typescript):** If [parameter properties](https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties) are used in the bot's implementation, they must be removed. All the attributes must be explicitly initialized in the constructor itself to work properly in IE11.
  For now, [it seems there is no proper solution](https://github.com/babel/babel/issues/7074) that can mantain the parameter properties from constructors and keep compatibility with IE11: when the code is transpiled to ES5, the attributes are not correctly initialized and the implementation fails to work.
  You can enable the option `'@typescript-eslint/no-parameter-properties': 'error'` in eslint to detect all the autoassigned attributes in constructors (parameter properties implementations).
- **Style issue - Blank space after messages:** IE11 seems to have a spacing issue when a `&lt;p&gt;` element is inside a `&lt;div&gt;` element, adding some blank space in the bottom of the `&lt;p&gt;` element. To fix this spacing issue, you can add these specific styles in a scss file (imported in `src/webchat/index.js`) that will be applied only for IE11:

  ```scss
  @media screen and (-ms-high-contrast: active), screen and (-ms-high-contrast: none) {
  /* IE10+ specific styles go here **/
  /**
  .hwaLqT is the parent div of every message. Check the correct class name generated for each bot and replace this one with the correct one.
  The option "white-space: normal" here in conjunction with "white-space: normal" in .text-user and .text-bot removes the blank space after the text message.
  **/
  .hwaLqT {
  	white-space: normal !important;
  	&gt; div {
  		/** Added this overflow in order to fix height issues (blank spaces) with some of the bot messages. */
  		overflow: auto;
  	}
  }
  .text-user {
  	&gt; div {
  		white-space: normal !important;
  	}
  }
  .text-bot {
  	&gt; div {
  		white-space: normal !important;
  	}
  }
  ```
